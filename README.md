### МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ <br>
### Федеральное государственное автономное образовательное учреждение высшего образования <br>
## Дальневосточный федеральный университет <br>

### Институт математики и компьютерных технологий
### Департамент информационных и компьютерных систем
### Отчёт о практическом задании по предмету АИСД

# Укладка планарного графа
### Просина Анна Алексеевна, гр. Б9121-09.03.03пикд

<h3 align="center">г. Владивосток, 2022 г.  </h3>
<hr>

# Содержание

- [*Содержание*](#содержание)

- [*Глоссарий*](#глоссарий)

- [*1 Введение*](#введение)

    - [*1.1 Неформальная постановка задачи*](#неформальная-постановка-задачи)

    - [*1.2 Применение*](#применение)

    - [*1.3 Обзор существующих методов*](#обзор-существующих-методов)

- [*2 Гамма-алгоритм*](#гамма-алгоритм)

    - [*2.1 Описание алгоритма*](#описание-алгоритма)

        - [*2.1.1 Входные данные*](#входные-данные)

        - [*2.1.2 Инициализация алгоритма*](#инициализация-алгоритма)

        - [*2.1.3 Общий шаг*](#общий-шаг)

        - [*2.1.4 Завершение работы*](#завершение-работы)
        
    - [*2.2 Математическое доказательство работы алгоритма*](#математическое-доказательство-работы-алгоритма)
        - [*2.2.1 Лемма 1*](#лемма-1)
       
        - [*2.2.2 Теорема Кёнига*](#теорема-кёнига)
       
        - [*2.2.3 Лемма 2*](#лемма-2)
        
        - [*2.2.3 Теорема о корректности гамма алгоритма*](#теорема-о-корректности-гамма-алгоритма)
    
    - [*2.3 Реализация алгоритма*](#реализация-алгоритма)

- [*3 Тестирование*](#тестирование)

- [*Список литературы*](#список-литературы)


# Глоссарий
- Гомеоморфизм - два графа гомеоморфны (или тождественны с точностью до вершин степени 2), если они оба могут быть получены из одного и того же графа «включением» в его ребра новых вершин степени 2. Если ребро графа изображено в виде линии, то можно на ней поставить точку и считать ее новой вершиной степени 2. 

- Граф – это топологичекая модель, которая состоит из множества вершин и множества соединяющих их рёбер. При этом значение имеет только сам факт, какая вершина с какой соединена.

- Инцидентность (смежность) – отношение между двумя вершинами, в котором существует ребро их соединяющее.

- Мост - ребро, после удаления которого, граф распадается на две компоненты связности. 

- Планарность - свойство графа, которое возникает, если существует укладка взятого графа на плоскости.

- Плоский граф - граф, изображенный на плоскости так, что никакие два ребра не имеют общих точек, кроме инцидентной им обоим вершины.

- Подграф - это часть графа, в которой мы берем некоторые его вершины и ребра. Другими словами, граф H является подграфом графа G, если вершины и ребра H являются подмножеством вершин и ребер G.

- Связный граф - граф, содержащий ровно одну компоненту связности. Это означает, что между любой парой вершин этого графа существует как минимум один путь.

- Сегмент - компонент связности графа с его подграфом.

- Укладка графа - такое его геометрическое изображение, при котором ребра графа пересекаются только в вершинах.


# Введение
Планарная укладка графа (planarity testing with embedding) - это алгоритм проверки графа на планарность и его укладки на плоскость.
Результат работы алгоритма - граф, уложенный без пересечения его рёбер.

## Неформальная постановка задачи
Цель данной работы:
- Изучить по литературным источникам данную задачу и описать ее в форме научного доклада
- Реализовать один из алгоритмов для решения задачи с использованием языка программирования С++
- Исследовать работу алгоритма и описать её

## Применение 
Примером применения данного алгоритма может послужить проблема изготовления электронных микросхем. Электрические цепи печатным способом наносятся на плату из изолирующего материала. Так как наносимые цепи не изолированы, то они не должны пересекаться. В контексте данной проблемы, важно решить, как расположить контакты на схеме, чтобы можно было без пересечений нанести цепи на плату. 

## Обзор существующих методов
1. Теорема Понтрягина-Куратовского - доказывает, что граф планарен тогда и только тогда, когда он не содержит подграфов, гомеоморфных K5 или K3,3. Так как этот критерий очень трудно проверить на практике, данная теорема представляет лишь теоретический интерес.
2. Гамма алгоритм – алгоритм, основанный на теореме Понтрягина-Куратовского, с помощью которого удобнее всего проверить граф на планарность и уложить его на плоскости. 
3. The Hopcroft-Tarjan Planarity Algorithm – алгоритм который проверяет граф на планарность и в зависимости от результата проверки также укладывает его на плоскости

# Гамма-алгоритм
Одним из варинатов, чтобы проверить планарность графа и произвести его плоскую укладку является гамма-алгоритм. Он был подробно описан Ириневым Антоном и Кашириным Виктором в работе под названием “Алгоритм плоской укладки графов”. 

## Описание-алгоритма
### Входные данные
На вход алгоритму подаются графы со следующими свойствами:
1.	Граф связный.
> Если нарушено свойство, то граф нужно укладывать отдельно по компонентам связности. 

2.	Граф содержит хотя бы один цикл.
> Если нарушено свойство , то граф — дерево и нарисовать его плоскую укладку тривиально.

3.	Граф не имеет мостов.
> Случай нарушения данного свойства рассмотрим более подробно. Если в графе есть мосты, то их нужно разрезать, провести отдельно плоскую укладку каждой компоненты связности, а затем соединить их мостами. Здесь может возникнуть трудность: в процессе укладки концевые вершины моста могут оказаться внутри плоского графа. Нарисуем одну компоненту связности, и будем присоединять к ней другие последовательно. Каждую новую компоненту связности будем рисовать в той грани, в которой лежит концевая вершина соответствующего моста. Так как граф связности мостами компонент связности является деревом, мы сумеем получить плоскую укладку.

**Замечание.** Если концевая вершина, принадлежащая новой (только что нарисованной) компоненте связности, также оказалась внутри, необходимо выполнить повторную укладку этой компоненты так, чтобы ребро, содержащее концевую вершину, принадлежало внешней грани.

### Инициализация алгоритма

Пусть дан граф G (см. рис. 1):

<p align="center">
<image
  src="/images/original_graph.svg"
  alt="Исходный граф"
  caption="Исходный граф"
  style="width: 400px;">
  <p align="center">Рис. 1</p>
</p>

Выбираем любой простой цикл в G, пусть это будет {1, 2, 3, 4, 5, 6}, укладываем его на плоскости, и получаем две грани: Г1 — внешнюю и Г2 — внутреннюю (см. рис. 2).

<p align="center">
<image
  src="/images/find_cycle.svg"
  alt="1"
  style="width: 400px;">
  <p align="center">Рис. 2</p>
</p>

Уже уложенную часть исходного графа будем обозначать как G′, тогда после первого шага G′ представляет собой цикл {1, 2, 3, 4, 5, 6}.

На каждом шаге будем строить множество сегментов. Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:

- ребро, оба конца которого принадлежат G′, но само оно не принадлежит G′;
- связную компоненту графа G – G′, дополненную всеми ребрами графа G, один из концов которых принадлежит связной компоненте, а второй из графа G′.

Вершины, которые одновременно принадлежат G′ и какому-то сегменту, назовем контактными вершинами. Для нашего примера сегменты изображены на рис. 3. Контактные вершины обведены в квадрат.

<p align="center">
<image
  src="/images/find_segments.svg"
  alt="2"
  style="width: 500px;">
  <p align="center">Рис. 3</p>
</p>

Если бы в каком-нибудь сегменте не было ни одной контактной вершины, то граф до построения множества сегментов был бы несвязный; если бы была только одна контактная вершина, то граф имел бы мост. Эти возможности заранее исключены, так что каждый сегмент имеет не менее двух контактных вершин. Поэтому в каждом сегменте имеется цепь между любой парой таких вершин.

Если все контактные вершины сегмента S имеют номера вершин какой-то грани Г, то мы будем говорить, что грань Г вмещает этот сегмент, в этом случае будем использовать следующее обозначение: S Г. Однако, может быть так, что не одна грань вмещает в себя сегмент S, а несколько. Множество таких граней обозначим Г(S), а их число |Г(S)|.

### Общий шаг 
Выделяются все сегменты Si и определяются числа |Г(Si)|. Если хоть одно из них равно 0, то граф не планарен, конец. Иначе, выбираем сегмент, для которого число |Г(S)| минимально, или любой из них, если таких сегментов несколько. В этом сегменте найдем произвольную цепь между двумя контактными вершинами и уложим ее в любую из граней множества Г(S). При этом данная грань разобьется на две. Уже уложенная часть графа G’ после укладки цепи увеличится, а сегмент, из которого вынута цепь, исчезнет или развалится на меньшие с новыми контактными вершинами, ведущими к вершинам G′.

В результате повторения общего шага будет либо получена плоская укладка, когда множество сегментов станет пустым, либо будет получено, что граф G не является планарным.

Вернемся к нашему примеру. Пока для любого i: Si {Г1, Г2}, |Г(Si)| = 2. Поэтому возьмем первый по номеру сегмент Si и в нем цепь {1, 4}; вставим эту цепь в грань Г2. После укладки цепи G’ увеличится и произойдут изменения в структуре сегментов (см. рис. 4, 5).

<p align="center">
<image
  src="/images/1_segment _aid.svg"
  alt="2"
  style="width: 400px;">
  <p align="center">Рис. 4</p>
</p>

<p align="center">
<image
  src="/images/4_segment.svg"
  alt="2"
  style="width: 400px;">
  <p align="center">Рис. 5</p>
</p>

Определим, какие грани вмещают новые сегменты. Теперь сегменты S1 и S3 можно уложить только в одну грань Г1, в то время как сегменты S2 и S4 можно уложить в две грани (для S2 это грани Г1 и Г2, для S4 - Г1 и Г3). Поэтому берем S1. Возьмем в нем цепь {2, 5} и уложим ее в Г1. Получим увеличенный граф G′ и уменьшенную систему сегментов (см. рис. 6, 7).

<p align="center">
<image
  src="/images/2_segment_laid.svg"
  alt="2"
  style="width: 420px;">
  <p align="center">Рис. 6</p>
</p>

<p align="center">
<image
  src="/images/3_segment.svg"
  alt="2"
  style="width: 300px;">
  <p align="center">Рис. 7</p>
</p>


### Завершение работы

Продолжая таким образом, в итоге получим плоскую укладку исходного графа G(см. рис. 8).

<p align="center">
<image
  src="/images/embedding_graph.svg"
  alt="2"
  style="width: 450px;">
  <p align="center">Рис. 8</p>
</p>

## Математическое доказательство работы алгоритма
Вначале приведем ряд вспомогательных утверждений, чтобы с их помощью доказать главную теорему о корректности гамма-алгоритма.

Назовем сегменты S<sub>1</sub> и S<sub>2</sub> **конфликтующими относительно уже уложенной части**, если:

-существует грань, которая вмещает каждый из сегментов;

-в сегментах S<sub>1</sub> и S<sub>2</sub> есть две цепи (между контактными вершинами) L<sub>1</sub> и L<sub>2</sub> соответственно, такие, что их невозможно уложить в одну грань без пересечения.


### Лемма 1

Конфликтующие сегменты S1 и S2 обладают следующим свойством: если |Г(S<sub>1</sub>)| ≥ 2 и |Г(S<sub>2</sub>)| ≥ 2, то Г(S<sub>1</sub>) = Г(S<sub>2</sub>) = 2.

**Доказательство.** Действительно, в противном случае, имея по определению одну общую вмещающую грань Г<sub>3</sub>, они бы имели еще по собственной вмещающей грани Г<sub>1</sub> и Г<sub>2</sub> соответственно. Тогда любые цепи из S<sub>1</sub> и S<sub>2</sub> могли бы разместиться в Г<sub>1</sub> и Г<sub>2</sub> соответственно, а значит и в Г<sub>3</sub>, причем без пересечения; следовательно, S<sub>1</sub> и S<sub>2</sub> не были бы конфликтующими. Противоречие. Что и требовалось доказать.

**Замечание.** Из доказанной леммы следует, что, если имеется сегмент S<sub>1</sub>, и еще сегмент S<sub>2</sub>, конфликтующий с S<sub>1</sub>, затем сегмент S<sub>3</sub>, конфликтующий с S<sub>2</sub> (но не с S<sub>1</sub>) и т. д., причем каждый вмещается в две грани, то эти грани являются общими для всех сегментов последовательности, и можно укладывать цепь L<sub>1</sub> из S<sub>1</sub> в первую грань Г<sub>1</sub>, L<sub>2</sub> из S<sub>2</sub> в Г<sub>2</sub>, L<sub>3</sub> из S<sub>3</sub> снова в Г<sub>1</sub> и т. д. до конца последовательности. Если цепочка сегментов замыкается в цикл четной длины, то проблем не будет; если в нечетный цикл, то в конце окажется, что два конфликтующих сегмента нужно разместить без пересечений в общую грань, что невозможно.

Сейчас нам понадобится в качестве вспомогательного утверждения теорема Д. Кёнига (D. König), которая полезна при решении и многих других задач.


### Теорема Кёнига

В графе все циклы четные тогда и только тогда, когда граф является двудольным.

**Доказательство.**

**Достаточность.** Рассмотрим двудольный граф. Начнем цикл в верхней доле. Нужно пройти по четному числу ребер, чтобы подняться снова в верхнюю долю. Следовательно, при замыкании цикла число ребер будет четным.

**Необходимость.** Если граф несвязный, то проведем доказательство отдельно для каждой компоненты. Пусть граф связный и все циклы в нем четные. Выделим произвольную вершину v<sub>0</sub> и найдем произвольные цепи между v<sub>0</sub> и всеми остальными вершинами (например, самые короткие, с помощью алгоритма Дейкстры). Если одна цепь (v<sub>0</sub>, v<sub>i</sub>) нечетной длины, то и любая цепь (v<sub>0</sub>, v<sub>i</sub>) нечетная, иначе бы эти цепи образовали нечетный цикл. Аналогично, если (v<sub>0</sub>, v<sub>i</sub>) — четная, то и любая (v<sub>0</sub>, v<sub>i</sub>) — четная. Разобьем вершины на две доли: в одну войдет вершина v0 и все, находящиеся от v<sub>0</sub> на четном расстоянии; в другую долю поместим все вершины, находящиеся от v<sub>0</sub> на нечетном расстоянии. Если вершины u<sub>1</sub> и u<sub>2</sub> принадлежат одной доле, то между ними не может быть ребра, иначе это ребро вместе с цепями (v<sub>0</sub>, u<sub>1</sub>) и (v<sub>0</sub>, u<sub>2</sub>) образовали бы нечетный цикл. Ч. т. д.

**Двудольным графом** называют граф, множество вершин которого можно разбить на две части (доли) таким образом, что концы любого ребра окажутся в разных частях.

**Частичной укладкой** G<sup>′</sup> планарного графа G называется граф, который можно получить из какойнибудь укладки графа G на плоскости удалением каких-то ребер и вершин.

В частичной укладке G<sup>′</sup> сопоставим каждому сегменту вершину в некотором постороннем служебном графе A(G<sup>′</sup>), где вершины соединяются ребрами, если соответствующие сегменты являются конфликтующими.



### Лемма 2

Если результатом некоторого шага работы гамма-алгоритма является частичная укладка G<sup>′</sup> планарного графа G такая, что |Г(S)| ≥ 2 для любого сегмента S относительно G<sup>′</sup>, то A(G<sup>′</sup>) — двудольный граф.

**Доказательство.** Докажем от противного. Пусть A(G<sup>′</sup>) — не двудольный, тогда по теореме Кенига в нем есть r - цикл нечетной длины. Этому циклу соответствует последовательность P сегментов S<sub>1</sub>, S<sub>2</sub>,…, S<sub>r</sub>, S<sub>1</sub> относительно G<sup>′</sup>, в которой каждые соседние сегменты конфликтующие. Поэтому на основании Леммы 1 Г(S<sub>i</sub>) = {Г<sub>1</sub>, Г<sub>2</sub>} (i = 1..r). Так как G<sup>′</sup> - частичная укладка графа, то все сегменты S<sub>1</sub>, S<sub>2</sub>,…, S<sub>r</sub> могут быть уложены, а так как соседние сегменты последовательности P конфликтующие, то они должны быть уложены в различные грани (Г<sub>1</sub>, Г<sub>2</sub>). Но это невозможно в силу нечетности числа сегментов r. Противоречие. Что и требовалось доказать.

Наконец, стало возможным доказать главную теорему.

### Теорема о корректности гамма алгоритма

Гамма-алгоритм корректен, то есть, если G — планарный граф, то результатом каждого шага гамма-алгоритма является частичная укладка G<sup>′</sup>.

**Доказательство.** Докажем индукцией по числу шагов.

База индукции очевидна: результат инициализации есть плоская укладка, так как уложенный цикл будет в любой укладке.

Пусть граф G<sup>′</sup><sub>k−1</sub>, полученный на (k−1)-м шаге, является частичной укладкой. На текущем шаге к нему присоединится цепь L: G<sup>′</sup><sub>k</sub> = G<sup>′</sup><sub>k−1</sub> U L. Докажем, что граф G<sup>′</sup><sub>k</sub> — тоже частичная укладка. Среди сегментов на текущем шаге нет такого S, что |Г(S)| = 0, иначе G<sup>′</sup><sub>k−1</sub> не был бы частичной укладкой. Значит, либо существует S такой, что |Г(S)| = 1, либо все S таковы, что |Г(S)| ≥ 2.

Первый случай означает, что укладка S в Г неизбежна, так что граф G<sup>′</sup><sub>k</sub> после добавления цепи из S останется частичной укладкой. Во втором случае построим граф A(G<sup>′</sup><sub>k−1</sub>), по Лемме 2 он двудольный. Возьмем его связную компоненту A<sup>′</sup>, этот граф тоже двудольный. Для сегментов из A<sup>′</sup> имеются ровно две грани Г<sub>1</sub> и Г<sub>2</sub>, вмещающие их. Раскидаем сегменты A<sup>′</sup> по граням Г<sub>1</sub> и Г<sub>2</sub> попеременно. В итоге будет получена частичная укладка.

Фактически, основой последней части доказательства было, что если граф A(G<sup>′</sup><sub>k−1</sub>) двудольный, то после удаления части ребер и вершин граф A(G<sup>′</sup><sub>k</sub>) тоже двудольный. Таким образом, в результате каждой итерации для планарного графа частичная укладка увеличивается, в конце мы получим плоскую укладку. Что и требовалось доказать.

### Следствие

Если граф G планарный, то гамма-алгоритм строит его плоскую укладку.
    
## Реализация алгоритма

На вход нашему алгоритму мы подаем двоичную матрицу, в которой указано количество вершин и их связи.
```cpp
    5
    0 1 1 0 1
    1 0 1 1 0
    1 1 0 1 0
    0 1 1 0 1
    1 0 0 1 0
```

Данный алгоритм является рекурсивным, поэтому его работа закончится, когда найдется такая укладка, в которой все вершины уложены на плоскость. 
Работа алгоритма начинается с поиска цикла, в котором будет самое наименьшее количество вершин, если таких циклов несколько, то берется первый найденный, который ещё не уложен на плоскости. (код работы нахождения цикла GetCycle and FindCycle).

```cpp
    bool FindCycle (vector <int>* result, vector<int> used, int parent, int v) {
        used.resize(n, 0);
        used[v] = 1;
        for (int i = 0; i < n; i++) {
            if (i == parent) continue;
            if (matrix[v][i] == 0) continue;
            if (used[i] == 0) {
                result->push_back(v);
                if (FindCycle(result, used, v, i)) {
                    //cycle was found
                    return true;
                }
                else {
                    result->pop_back();
                }
            }
            if (used[i] == 1) {
                result->push_back(v);
                auto cycle = new vector <int>;
                for (int j = 0; j < result->size(); j++) {
                    if ((*result)[j] == i) {
                        for (int k = j; k < result->size(); k++) {
                            (*cycle).push_back((*result)[k]);
                        }
                        result->clear();
                        for (int & l : *cycle) {
                            result->push_back(l);
                        }
                        return true;
                        }
                    }
                return true;
                }
        }
        used[v] = 2;
        return false;
    }
```
Найденный цикл нужно расположить на плоскости. Так как укладка графа должна быть плоской, то нужно учитывать, какие вершины уже уложены на плоскости и как они связаны, чтобы не возникло пересечения ребер. Для этого нужно найти сегменты, через алгоритм поиска в глубину, уже уложенных вершин и расположить их.
    
```cpp
    void dfsSegments(vector <int> used, vector<bool>* laidVertexes, Graph* result, int v) {
        used[v] = 1;
        for (int i = 0; i < n; i++) {
            if (matrix[v][i]==1){
                result->NewEdge(v,i);
                if (used[i] == 0 && !(*laidVertexes)[i]) dfsSegments(used, laidVertexes, result, i);
            }
        }
    }
```
В результате, на выходе в консоли у нас будет выводится связанные вершины, фраза с информацией является ли граф планарным или нет, полученные внешняя и внутренние грани и вид планарной укладки.

```cpp
    //Пример выходных данных в консоли
    Graph:
    0 -- 1;
    0 -- 2;
    0 -- 4;
    1 -- 2;
    1 -- 3;
    2 -- 3;
    3 -- 4;

    Graph is planarity. Edges:
    Faces size = 8
    External face:
    3 2 0 4
    Interior faces:
    0 1 2
    0 4 3 1
    3 2 0 4
    3 2 1
```    
    
# Тестирование

Так как возникает трудность в проверке правильности результата работы алгоритма, для проверки выходных данных мы будем использовать визуализатор написанный через graphviz на языке DOT, который будет отображать, возможна ли укладка планарного графа на основе входных граней. (фото с визуализатора + входные данные)
    
<p align="center">
<image
  src="/images/graphviz.png"
  alt="2"
  style="width: 450px;">
  <p align="center">Построенный граф на основе матрицы из примера</p>
</p>
    
Так как алгоритм работает в основном с ребрами, имеющий граф, то проверка всех возможных вариантов алгоритмически займет время 0(n), где n – количество ребер графа. 

# Список литературы
1. [Graph Planarity Testing with Hierarchical Embedding Constraints Giuseppe Liottaa, Ignaz Rutterb, Alessandra Tappinia.](https://arxiv.org/pdf/1904.12596.pdf)
2. [Иринёв Антон, Каширин Виктор Алгоритм плоской укладки графов.](https://studfile.net/preview/1869599/)
3. [Kurt Mehlhorn and Petra Mutzel., On the embedding phase of the Hopcroft and Tarjan planarity testing algorithm., Algorithmica, 1996](https://domino.mpi-inf.mpg.de/internet/reports.nsf/efc044f1568a0058c125642e0064c817/02b4941bb1079240c12560b700590d27/$FILE/MPI-I-94-117.pdf)
4. [Статья на habr.com. Теория Графов.](https://habr.com/ru/post/565998/)
5. https://neerc.ifmo.ru/wiki/index.php?title=Гамма-алгоритм
6. https://neerc.ifmo.ru/wiki/index.php?title=Укладка_графа_на_плоскости – укладка графа на плоскости
7. https://neerc.ifmo.ru/wiki/index.php?title=Теорема_Понтрягина-Куратовского – теорема, которая доказывается с помощью гамма-алгоритма
8. https://portal.tpu.ru/SHARED/t/TRACEY/Courses/Graph_Theory/Tab1/graph_lec_09.pdf - алгоритм укладки планарного графа на плоскости
9. https://github.com/tehnik819/Gamma-Algorithm-Java/blob/master/src/Graph.java - код
10. https://www.youtube.com/watch?v=MS98VuAG9Yo – как нарисовать плоский граф через гамма-алгоритм
11. https://users.math-cs.spbu.ru/~okhotin/teaching/tcs1_2016/okhotin_tcs1_2016_l5.pdf - лекция по плоским графам
12. https://dic.academic.ru/dic.nsf/ruwiki/628470 - гамма-алгоритм
13. https://textarchive.ru/c-2330757-p3.html - 
14.	https://theslide.ru/uncategorized/osnovnye-ponyatiya-teorii-grafov - теория графов
15.	https://studopedia.ru/2_84961_ploskie-i-planarnie-grafi-ploskie-karti-teorema-eylera.html - плоские и планарные графы
16.	https://progr-system.ru/wp-content/uploads/Math/МАПКС-08-ПлоскиеПланарныеГрафыРаскраска.pdf - плоские и планарные графы
17.	https://prezi.com/p/ezmde7t_sf6h/presentation/ - алгоритмы проверки планарности графов
18.	https://www.researchgate.net/publication/228898512_The_Gamma_Algorithm_in_Convex_Cone_Analysis_of_Hyperspectral_Images - гамма алгоритм
19.	https://www.youtube.com/watch?v=das1x_ntedU - Укладка планарных графов, алгоритм D. Eppstein
20.	 https://studfile.net/preview/1869599/ - гамма алгоритм для плоской укладки графа
21.	https://cs.brown.edu/people/rtamassi/gdhandbook/chapters/planarity.pdf
22.	https://www.researchgate.net/publication/228993896_The_Hopcroft-Tarjan_Planarity_Algorithm - укладка планарного графа
23.	https://en.wikipedia.org/wiki/Planarity_testing 
24.	https://towardsdatascience.com/graph-planarity-and-path-addition-method-of-hopcroft-tarjan-for-planarity-testing-c56d2df2b0b3 - hopcroft-tarjan planarity testing 
25.	https://github.com/shawnwanderson/Hopcroft-Tarjan-Planarity-Testing - code c++ of Hopcroft tarjan testing of planarity
26.	 https://jgaa.info/accepted/2008/GutwengerKleinMutzel2008.12.1.pdf
27.	https://link.springer.com/content/pdf/10.1007/978-3-540-77537-9_9.pdf 
